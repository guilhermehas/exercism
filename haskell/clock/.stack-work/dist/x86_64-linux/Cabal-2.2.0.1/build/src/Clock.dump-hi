
==================== FINAL INTERFACE ====================
2019-01-14 01:54:56.88502992 UTC

interface exercism-clock-2.3.0.8-6hqjfRTyXqfL6LFF5ie5Kc:Clock 8043
  interface hash: f7e39bb8dc72d7bf9d26e42272bd6f43
  ABI hash: 993cf5cba58e36ef2fcce44380f503ba
  export-list hash: df37d672657bb959d85ad969712df90e
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 1f596daf84c7527444ae092b33472386
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Clock.addDelta
  Clock.fromHourMin
  Clock.toString
module dependencies:
package dependencies: base-4.11.1.0* ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Real b4beb0389ba1ad5d9640aae67848c5d3
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
aea247404b55e4d670c0a3e7f286f655
  $fEqClock :: GHC.Classes.Eq Clock.Clock
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Clock.Clock Clock.$fEqClock_$c== Clock.$fEqClock_$c/= -}
aea247404b55e4d670c0a3e7f286f655
  $fEqClock_$c/= :: Clock.Clock -> Clock.Clock -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Clock.Clock) (y :: Clock.Clock) ->
                 case x of wild { Clock.Clock a1 a2 ->
                 case y of wild1 { Clock.Clock b1 b2 ->
                 case GHC.Classes.eqInt a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.eqInt a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
aea247404b55e4d670c0a3e7f286f655
  $fEqClock_$c== :: Clock.Clock -> Clock.Clock -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Clock.Clock) (w1 :: Clock.Clock) ->
                 case w of ww { Clock.Clock ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Clock.Clock ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Clock.$w$c== ww4 ww2 ww9 ww7 } } } }) -}
3f37528a2776f30c57ae6b18f1aa5e2d
  $tc'Clock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16971848532848815323##
                   11302482032099718276##
                   Clock.$trModule
                   Clock.$tc'Clock2
                   0#
                   Clock.$tc'Clock1) -}
66e80b81dd6100ff56f8816cbfae4ec7
  $tc'Clock1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
149c46833247e95631a252f7d8a033d3
  $tc'Clock2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Clock.$tc'Clock3) -}
2093eef6dc80634d53f7aca7a91e3abe
  $tc'Clock3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Clock"#) -}
e7945dd060a8f31961dc4600fbf0e387
  $tcClock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5835548719961233533##
                   9524009073146354931##
                   Clock.$trModule
                   Clock.$trModule1
                   0#
                   GHC.Types.krep$*) -}
25eefb22098816f47e2faa6daad357d5
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Clock.$trModule3 Clock.$trModule1) -}
c7c2d20f8e0a75510ef232d539e216d6
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Clock.$trModule2) -}
be375e733364cc2c62e07123730e9177
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Clock"#) -}
941b6ab41cda5be1da8cebc5305a67c0
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Clock.$trModule4) -}
6661c1a8d4e72771b6167649d338b583
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("exercism-clock-2.3.0.8-6hqjfRTyXqfL6LFF5ie5Kc"#) -}
d6a84d21a0c3709513c73325319f23ca
  $w$c== ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.==# ww ww2 of lwild {
                   DEFAULT -> GHC.Types.False 1# -> GHC.Classes.eqInt ww1 ww3 }) -}
bac40fb84d7047860a1fffab79471c5d
  $wfromHourMin ::
    GHC.Types.Int
    -> GHC.Types.Int -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U(U)>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.Int) ->
                 (# case w of wild { GHC.Types.I# x ->
                    case w1 of ww { GHC.Types.I# ww1 ->
                    case GHC.Classes.divInt# ww1 60# of ww4 { DEFAULT ->
                    case GHC.Classes.modInt#
                           (GHC.Prim.+# x ww4)
                           24# of ww2 { DEFAULT ->
                    GHC.Types.I# ww2 } } } },
                    case w1 of wild1 { GHC.Types.I# x ->
                    case GHC.Classes.modInt# x 60# of ww2 { DEFAULT ->
                    GHC.Types.I# ww2 } } #)) -}
1c882c6a6bc2092e95a070b75f8f02f9
  $wshow' :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Show.$wshowSignedInt
                        0#
                        ww
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 let {
                   r :: GHC.Base.String = GHC.Types.: @ GHC.Types.Char ww5 ww6
                 } in
                 case GHC.List.$wlenAcc @ GHC.Types.Char r 0# of ww2 { DEFAULT ->
                 let {
                   y :: GHC.Prim.Int# = GHC.Prim.-# 2# ww2
                 } in
                 case GHC.Prim.<# 0# y of lwild {
                   DEFAULT -> r
                   1#
                   -> let {
                        lvl :: [GHC.Types.Char]
                        = GHC.Types.: @ GHC.Types.Char Clock.toString2 r
                      } in
                      letrec {
                        $wxs :: GHC.Prim.Int# -> [GHC.Types.Char]
                          {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                        = \ (ww1 :: GHC.Prim.Int#) ->
                          case ww1 of ds1 {
                            DEFAULT
                            -> GHC.Types.:
                                 @ GHC.Types.Char
                                 Clock.toString2
                                 ($wxs (GHC.Prim.-# ds1 1#))
                            1# -> lvl }
                      } in
                      $wxs y } } }) -}
3b9d47ecedeb134f2d7a31c0651d3933
  $wtoString :: GHC.Prim.Int# -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Types.Int) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (Clock.$wshow' ww)
                   (GHC.CString.unpackAppendCString#
                      Clock.toString1
                      (case ww1 of ww2 { GHC.Types.I# ww3 -> Clock.$wshow' ww3 }))) -}
aea247404b55e4d670c0a3e7f286f655
  data Clock = Clock GHC.Types.Int GHC.Types.Int
099de4a40a2858ab99f9ae48312931aa
  addDelta ::
    GHC.Types.Int -> GHC.Types.Int -> Clock.Clock -> Clock.Clock
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U)><L,1*U(U)><S,1*U(1*U(U),1*U(U))>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Clock.Clock) ->
                 case w2 of ww { Clock.Clock ww1 ww2 ->
                 case Clock.$wfromHourMin
                        (case w of wild { GHC.Types.I# x ->
                         case ww1 of wild1 { GHC.Types.I# y ->
                         GHC.Types.I# (GHC.Prim.+# x y) } })
                        (case ww2 of wild { GHC.Types.I# x ->
                         case w1 of wild1 { GHC.Types.I# y ->
                         GHC.Types.I# (GHC.Prim.+# x y) } }) of ww3 { (#,#) ww4 ww5 ->
                 Clock.Clock ww4 ww5 } }) -}
5f02a545ab53224edfa142522a476aa4
  fromHourMin :: GHC.Types.Int -> GHC.Types.Int -> Clock.Clock
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.Int) ->
                 case Clock.$wfromHourMin w w1 of ww { (#,#) ww1 ww2 ->
                 Clock.Clock ww1 ww2 }) -}
a2efd22fd68f0261b6df7f63e77f2470
  toString :: Clock.Clock -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Clock.Clock) ->
                 case w of ww { Clock.Clock ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 Clock.$wtoString ww4 ww2 } }) -}
eae0e8e751c8328c4415cf88b1913f5e
  toString1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (":"#) -}
10b5b1629249752f47ef4552b86607fe
  toString2 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '0'#) -}
instance [safe] GHC.Classes.Eq [Clock.Clock] = Clock.$fEqClock
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

