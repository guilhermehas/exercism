
==================== FINAL INTERFACE ====================
2019-02-11 04:07:15.950870548 UTC

interface rail-fence-cipher-1.1.0.4-DOSKZLmB5707zudzyH0AhU:RailFenceCipher 8043
  interface hash: 293579e69cbb1e9424da7f551822406f
  ABI hash: f562a801a34a2b946c69ad9014e30a56
  export-list hash: 040945616b0457ca5b963184547b114e
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 1f596daf84c7527444ae092b33472386
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  RailFenceCipher.decode
  RailFenceCipher.encode
module dependencies:
package dependencies: base-4.11.1.0* ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.OldList 1b35aa3c6805ff7c8887a35a866fe006
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
b3fab6ec26275a8ffb2555368b94e9eb
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   RailFenceCipher.$trModule3
                   RailFenceCipher.$trModule1) -}
553760116fd03c0be9808367bb828dfd
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS RailFenceCipher.$trModule2) -}
fa82fbc9f75404ea4bd81692736c1097
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("RailFenceCipher"#) -}
8f247e644024451aace49b654a53bf27
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS RailFenceCipher.$trModule4) -}
66fe1b4c46c2a5abaa3600afd878421a
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("rail-fence-cipher-1.1.0.4-DOSKZLmB5707zudzyH0AhU"#) -}
563dd368613db728ffd1bd41e6d069fe
  $wgo :: GHC.Prim.Int# -> GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,1*U>, Inline: [0] -}
4a66fcabde2841452b0d170fbebe9439
  $wlvl ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.<# ww ww2 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww ww2 of lwild1 {
                        DEFAULT -> GHC.Types.GT 1# -> GHC.Classes.compareInt ww1 ww3 }
                   1# -> GHC.Types.LT }) -}
bef283aab69f9e4c8d744c53035126bb
  decode :: GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,U>,
     Unfolding: (\ (n :: GHC.Types.Int) (str :: GHC.Base.String) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Char str 0# of ww2 { DEFAULT ->
                 case GHC.Prim.<# 0# ww2 of lwild {
                   DEFAULT
                   -> GHC.Base.map
                        @ (GHC.Types.Char, (GHC.Types.Char, GHC.Types.Char))
                        @ GHC.Types.Char
                        RailFenceCipher.decode2
                        (Data.OldList.sortBy
                           @ (GHC.Types.Char, (GHC.Types.Char, GHC.Types.Char))
                           RailFenceCipher.decode1
                           (RailFenceCipher.decode_go2
                              (RailFenceCipher.encode n (GHC.Types.[] @ GHC.Types.Char))
                              str))
                   1#
                   -> GHC.Base.map
                        @ (GHC.Types.Char, (GHC.Types.Char, GHC.Types.Char))
                        @ GHC.Types.Char
                        RailFenceCipher.decode2
                        (Data.OldList.sortBy
                           @ (GHC.Types.Char, (GHC.Types.Char, GHC.Types.Char))
                           RailFenceCipher.decode1
                           (RailFenceCipher.decode_go2
                              (RailFenceCipher.encode n (RailFenceCipher.$wgo 97# ww2))
                              str)) } }) -}
f3e1a67a4ff7f65c299f9c953db1e79d
  decode1 ::
    (GHC.Types.Char, (GHC.Types.Char, GHC.Types.Char))
    -> (GHC.Types.Char, (GHC.Types.Char, GHC.Types.Char))
    -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),A)><S(S(S)L),1*U(1*U(U),A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: (GHC.Types.Char, (GHC.Types.Char, GHC.Types.Char)))
                   (y :: (GHC.Types.Char,
                          (GHC.Types.Char, GHC.Types.Char)))[OneShot] ->
                 case x of wild { (,) x1 ds1 ->
                 case x1 of wild1 { GHC.Types.C# x2 ->
                 case y of wild2 { (,) x3 ds2 ->
                 case x3 of wild3 { GHC.Types.C# y1 ->
                 case GHC.Prim.eqChar# x2 y1 of lwild {
                   DEFAULT
                   -> case GHC.Prim.leChar# x2 y1 of lwild1 {
                        DEFAULT -> GHC.Types.GT 1# -> GHC.Types.LT }
                   1# -> GHC.Types.EQ } } } } }) -}
fbb0c53e9b6c1466fba9aa7a3f4e3f7b
  decode2 ::
    (GHC.Types.Char, (GHC.Types.Char, GHC.Types.Char))
    -> GHC.Types.Char
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LS)),1*U(A,1*U(A,1*U(U)))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: (GHC.Types.Char, (GHC.Types.Char, GHC.Types.Char))) ->
                 case x of wild { (,) ds1 y ->
                 case y of wild1 { (,) ds2 y1 -> y1 } }) -}
b827e1cc3f3baefad05e8f92be3b6f64
  decode_go2 ::
    [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> [(GHC.Types.Char, (GHC.Types.Char, GHC.Types.Char))]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
fa10c420c97934c123833eda88f1b21f
  encode :: GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: (\ (n :: GHC.Types.Int) (sentence :: GHC.Base.String) ->
                 GHC.Base.map
                   @ ((GHC.Types.Int, GHC.Types.Int),
                      (GHC.Types.Char, (GHC.Types.Int, GHC.Types.Int, GHC.Types.Bool)))
                   @ GHC.Types.Char
                   RailFenceCipher.encode6
                   (Data.OldList.sortBy
                      @ ((GHC.Types.Int, GHC.Types.Int),
                         (GHC.Types.Char, (GHC.Types.Int, GHC.Types.Int, GHC.Types.Bool)))
                      RailFenceCipher.encode5
                      (RailFenceCipher.encode_go2
                         sentence
                         (case GHC.List.$witerate
                                 @ (GHC.Types.Int, GHC.Types.Int, GHC.Types.Bool)
                                 (let {
                                    n1 :: GHC.Types.Int
                                    = case n of wild { GHC.Types.I# x ->
                                      GHC.Types.I# (GHC.Prim.-# x 1#) }
                                  } in
                                  let {
                                    lvl :: GHC.Types.Int
                                    = case n1 of wild { GHC.Types.I# x ->
                                      GHC.Types.I# (GHC.Prim.-# x 1#) }
                                  } in
                                  let {
                                    lvl1 :: (GHC.Types.Int, GHC.Types.Bool) = (lvl, GHC.Types.False)
                                  } in
                                  \ (ds :: (GHC.Types.Int, GHC.Types.Int, GHC.Types.Bool)) ->
                                  case ds of wild { (,,) x y dy ->
                                  let {
                                    ds1 :: (GHC.Types.Int, GHC.Types.Bool)
                                    = case y of wild1 { GHC.Types.I# x1 ->
                                      case x1 of wild2 {
                                        DEFAULT
                                        -> case n1 of wild3 { GHC.Types.I# y1 ->
                                           case GHC.Prim.==# wild2 y1 of lwild {
                                             DEFAULT
                                             -> (case dy of wild4 {
                                                   GHC.Types.False
                                                   -> GHC.Types.I# (GHC.Prim.+# wild2 -1#)
                                                   GHC.Types.True
                                                   -> GHC.Types.I# (GHC.Prim.+# wild2 1#) },
                                                 dy)
                                             1# -> lvl1 } }
                                        0# -> RailFenceCipher.encode3 } }
                                  } in
                                  (case x of wild1 { GHC.Types.I# x1 ->
                                   GHC.Types.I# (GHC.Prim.+# x1 1#) },
                                   case ds1 of wild1 { (,) y' dy' -> y' },
                                   case ds1 of wild1 { (,) y' dy' -> dy' }) })
                                 RailFenceCipher.encode1 of ww { (#,#) ww1 ww2 ->
                          GHC.Types.:
                            @ (GHC.Types.Int, GHC.Types.Int, GHC.Types.Bool)
                            ww1
                            ww2 })))) -}
01cf65a1f988fdebba6be2474d9be703
  encode1 :: (GHC.Types.Int, GHC.Types.Int, GHC.Types.Bool)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((RailFenceCipher.encode2, RailFenceCipher.encode2,
                  GHC.Types.True)) -}
b27b68b4f26b7131d6dd0c75849b83b9
  encode2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
7bf1b6d4a5cc9c0a118e3842a72502dd
  encode3 :: (GHC.Types.Int, GHC.Types.Bool)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((RailFenceCipher.encode4, GHC.Types.True)) -}
c154e3fc54178c0566a423090361b221
  encode4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
23b36980f7cfcd4ca2e13e60b15277c5
  encode5 ::
    ((GHC.Types.Int, GHC.Types.Int),
     (GHC.Types.Char, (GHC.Types.Int, GHC.Types.Int, GHC.Types.Bool)))
    -> ((GHC.Types.Int, GHC.Types.Int),
        (GHC.Types.Char, (GHC.Types.Int, GHC.Types.Int, GHC.Types.Bool)))
    -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(S)L)L),1*U(1*U(1*U(U),1*U(U)),A)><S(S(S(S)L)L),1*U(1*U(1*U(U),1*U(U)),A)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ((GHC.Types.Int, GHC.Types.Int),
                          (GHC.Types.Char, (GHC.Types.Int, GHC.Types.Int, GHC.Types.Bool))))
                   (w1 :: ((GHC.Types.Int, GHC.Types.Int),
                           (GHC.Types.Char,
                            (GHC.Types.Int, GHC.Types.Int, GHC.Types.Bool)))) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { (,) ww4 ww5 ->
                 case ww4 of ww6 { GHC.Types.I# ww7 ->
                 case w1 of ww8 { (,) ww9 ww10 ->
                 case ww9 of ww11 { (,) ww12 ww13 ->
                 case ww12 of ww14 { GHC.Types.I# ww15 ->
                 RailFenceCipher.$wlvl ww7 ww5 ww15 ww13 } } } } } }) -}
c162ec66312628627840d874b57a09c7
  encode6 ::
    ((GHC.Types.Int, GHC.Types.Int),
     (GHC.Types.Char, (GHC.Types.Int, GHC.Types.Int, GHC.Types.Bool)))
    -> GHC.Types.Char
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(SL)),1*U(A,1*U(1*U(U),A))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: ((GHC.Types.Int, GHC.Types.Int),
                          (GHC.Types.Char,
                           (GHC.Types.Int, GHC.Types.Int, GHC.Types.Bool)))) ->
                 case x of wild { (,) ds1 y ->
                 case y of wild1 { (,) x1 ds2 -> x1 } }) -}
2498e71c3cb6a1ed9f127f7b9ea7000f
  encode_go2 ::
    [GHC.Types.Char]
    -> [(GHC.Types.Int, GHC.Types.Int, GHC.Types.Bool)]
    -> [((GHC.Types.Int, GHC.Types.Int),
         (GHC.Types.Char, (GHC.Types.Int, GHC.Types.Int, GHC.Types.Bool)))]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

